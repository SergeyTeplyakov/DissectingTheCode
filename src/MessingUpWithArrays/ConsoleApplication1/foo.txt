<p>Arrays are one of the basic building blocks of every applications. Even if you do not use arrays directly every day you definitely use them indirectly as part of almost any library. 
<p>C# has arrays from the very beginning and back in the day that was the only "generic"-like and type safe data structure available. Today you may use them less frequently directly but every time you need to squeeze the performance, there is a chance you'll switch to them from some higher-level data structure like <strong>List&lt;T&gt;</strong>. 
<p><a href="http://mattwarren.org/2017/05/08/Arrays-and-the-CLR-a-Very-Special-Relationship/">Array and the CLR has a very special relationship</a> but today we're going to explore them from the user's point of view. We'll talk about the following: 
<ul>
<li>Will explore one of the weirdest C# feature called array covariance 
<li>Will discuss array's internal structure 
<li>Will explore some perf tricks that we can do to squeeze even more perf from the array</li></ul>
<p><b>The whole series</b> 
<ul>
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/05/26/managed-object-internals-part-1-layout/">Managed object internals, Part 1. The Layout</a> 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/09/06/managed-object-internals-part-2-object-header-layout-and-the-cost-of-locking/">Managed object internals, Part 2. Object header layout and the cost of locking</a> 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/09/12/managed-object-internals-part-3-the-layout-of-a-managed-array/">Managed object internals, Part 3. The layout of a managed array</a></li></ul>
<h4>Array covariance, and a bit of history</h4>
<p>One of the strangest feature in the C# language is an array covariance: an ability to assign an array of type <strong>T</strong> to array of type object or any other base type of <strong>T</strong>. <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">string</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">[] strings </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">[] { </font><span style="color: "><font color="#d69d85">"1"</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#d69d85">"2"</font></span><font color="#dcdcdc"> };</font><br><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc">[] objects </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> strings;</font></font></font></pre>
<p>This conversion is not totally type safe. If the objects variable is used only for reading the data from it, everything is fine. But if you’ll try to modify the array then failure can occur if the argument will be of an incompatible type: </p><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#dcdcdc"><font style="font-size: 11pt">objects[</font></font><font style="font-size: 11pt"><span style="color: "><font color="#b5cea8">0</font></span><font color="#dcdcdc">] </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">; </font></font><span style="color: "><font style="font-size: 11pt" color="#57a64a">//runtime error</font></span></font></pre>
<p>There is a well-known joke in the .NET community about this feature: C# authors back in the inception days were trying really hard to copy every aspect of the Java ecosystem to the CLR world, so they copied language design issues as well. 
<p>But I don't think this is the reason:) 
<p>Back in the late 90-s, the CLR doesn't have generics. Right? And how in this case a language user can write reusable code that deals with array of arbitrary data types? For instance, how to write a function that dumps arbitrary arrays to the console? 
<p>One way to do that is to define a function that takes <strong>object[]</strong> and force every caller to convert the array manually by copying it into the array of objects. This will work, but would be highly inefficient. Another solution is to allow conversion from any arrays of reference types to <strong>object[]</strong>, i.e. preserve IS-A relationship for <strong>Derived[]</strong> to <strong>Base[]</strong> where <strong>Derived</strong> inherits from the <strong>Base</strong>. In case of arrays of value types the conversion won’t work but at least some genericity can be achieved. 
<p>Lack of generics in the first CLR version forced designers to weaken the type system. But that decision (I assume) was deliberate, not just a copycat from the Java ecosystem. 
<p>The internal structure and implementation details 
<p>Array covariance opens a hole in the type system at compile time, but it doesn't mean that a type error will crash the application (similar "error" in C++ will lead to an “undefined behavior”). The CLR will ensure that the type safety holds, but the check will happen at runtime. To do that the CLR should store the type of array element and make a check when a user tries to change an array instance. Luckily this check is only needed for arrays of reference types because structs are 'sealed' and does not support inheritance. 
<p>Even though there is an implicit conversion between different value types (like from <strong>int</strong> to <strong>byte</strong>), there is <b>no</b> implicit or explicit conversions between <strong>int[]</strong> and <strong>byte[]</strong>. Array covariance conversion is <b>reference conversion</b> that doesn't change the layout of the converted object and keeps a referential identity of the object being converted. 
<p>In the older version of the CLR, arrays of reference and value types had different layouts. An array of reference type had a reference to a type handle of an element in every instance: 
<p><a href="$Arrays_Figure_1[4].png"><img title="Arrays_Figure_1" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Arrays_Figure_1" src="$Arrays_Figure_1_thumb[2].png" width="1889" height="1051"></a>
<p>This has been changed in recent version of the CLR and now the element type is stored in the method table: 
<p><a href="$Arrays_Figure_2[4].png"><img title="Arrays_Figure_2" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Arrays_Figure_2" src="$Arrays_Figure_2_thumb[2].png" width="2005" height="1176"></a>
<p>For more information about the layout, see the following snippets in the CoreClr codebase: 
<ul>
<li><a href="https://github.com/dotnet/coreclr/blob/5c07c5aa98f8a088bf25099f1ab2d38b59ea5478/src/vm/object.h#L805-L807">ArrayBase::GetArrayElementTypeHandle</a> declaration:</li></ul><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#57a64a"><span style="color: "><font style="font-size: 11pt">// Get the element type for the array, this works whether the element</font></span><font style="font-size: 11pt"><br><span style="color: ">// type is stored in the array or not</span></font></font><font style="font-size: 11pt"><br><span style="color: "><font color="#569cd6">inline</font></span><font color="#dcdcdc"> TypeHandle GetArrayElementTypeHandle</font><span style="color: "><font color="#b4b4b4">()</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">const</font></span></font><span style="color: "><font style="font-size: 11pt" color="#b4b4b4">;</font></span></font></pre>
<ul>
<li><a href="https://github.com/dotnet/coreclr/blob/5c07c5aa98f8a088bf25099f1ab2d38b59ea5478/src/vm/object.h#L949-L953">PtrArray::GetArrayElementTypeHandle</a> implementation:</li></ul><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#4ec9b0"><font style="font-size: 11pt">TypeHandle</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">GetArrayElementTypeHandle</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#b4b4b4"><span style="color: ">()</span><br><span style="color: ">{</span></font><br><font color="#dcdcdc">	LIMITED_METHOD_CONTRACT</font><span style="color: "><font color="#b4b4b4">;</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">GetMethodTable</font></span><span style="color: "><font color="#b4b4b4">()-&gt;</font></span><font color="#dcdcdc">GetApproxArrayElementTypeHandle</font><font color="#b4b4b4"><span style="color: ">();</span><br></font></font><span style="color: "><font style="font-size: 11pt" color="#b4b4b4">}</font></span></font></pre>
<ul>
<li><a href="https://github.com/dotnet/coreclr/blame/559c603f2e9d2d89cca6c7c6731f720a7935e369/src/vm/methodtable.h#L2921-L2926">Table::GetApproxArrayElementTypeHandle</a> implementation:</li></ul><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#4ec9b0"><font style="font-size: 11pt">TypeHandle</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">GetApproxArrayElementTypeHandle</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#b4b4b4"><span style="color: ">()</span><br><span style="color: ">{</span></font><br><font color="#dcdcdc">	LIMITED_METHOD_DAC_CONTRACT</font><span style="color: "><font color="#b4b4b4">;</font></span><br><font color="#dcdcdc">	_ASSERTE</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">IsArray</font><span style="color: "><font color="#b4b4b4">());</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><span style="color: "><font color="#b4b4b4">::</font></span><font color="#dcdcdc">FromTAddr</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">m_ElementTypeHnd</font><font color="#b4b4b4"><span style="color: ">);</span><br></font></font><span style="color: "><font style="font-size: 11pt" color="#b4b4b4">}</font></span></font></pre>
<ul>
<li>and <a href="https://github.com/dotnet/coreclr/blob/559c603f2e9d2d89cca6c7c6731f720a7935e369/src/vm/methodtable.h#L4173">MethodTable::m_ElementTypeHnd</a> declaration:</li></ul><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">union</font></font></span><font style="font-size: 11pt"><br><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">	PerInstInfo_t m_pPerInstInfo</font><span style="color: "><font color="#b4b4b4">;</font></span><br><font color="#dcdcdc">	TADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_ElementTypeHnd</font><span style="color: "><font color="#b4b4b4">;</font></span><br><font color="#dcdcdc">	TADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMultipurposeSlot1</font><font color="#b4b4b4"><span style="color: ">;</span><br></font></font><span style="color: "><font style="font-size: 11pt" color="#b4b4b4">};</font></span></font></pre>
<p>I'm not sure when the array layout was changed (*) but it seems there was a tradeoff between speed and (managed) memory. Initial implementation (when the type handle was stored in every array instance) should've been faster due to memory locality, but definitely had non-negligible memory overhead. Back then all arrays of reference types had shared method tables. But right now this is no longer the case: each array of reference type has its own method table that <a href="https://github.com/dotnet/coreclr/blob/7590378d8a00d7c29ade23fada2ce79f4495b889/src/vm/array.cpp#L272">points to the same EEClass</a> and the pointer to an element type handle. 
<p>(*) Maybe somebody from the CLR team can shed some lights on that. 
<p>We know how the CLR stores the element type of an array and now we can explore the CoreClr codebase to see how the actual check is implemented. 
<p>First, we need to find the place where the check is happening. Array is a very special type for the CLR and there is no "go to declaration" button in the IDE that will "decompile" the array and show the source code. But we know that the check happens in the indexer setter that corresponds to a set of IL instructions <strong>StElem</strong>*: 
<ul>
<li><a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.stelem_i4(v=vs.110).aspx"><strong>StElem.i4</strong></a> for array of integers, 
<li><a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.stelem(v=vs.110).aspx"><strong>StElem</strong></a> for array of arbitrary value types and 
<li><a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.stelem_ref%28v=vs.110%29.aspx"><strong>StElem.ref</strong></a> for array of reference types.</li></ul>
<p>Knowing the instruction, we can easily find the implementation in the codebase. As far as I can tell, the implementation resides in <a href="https://github.com/dotnet/coreclr/blob/7590378d8a00d7c29ade23fada2ce79f4495b889/src/vm/jithelpers.cpp#L3386-L3458">jithelpers.cpp</a>. Here is a slightly simplified version of the method <strong>JIT_Stelem_Ref_Portable:</strong> <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#57a64a"><span style="color: "><font style="font-size: 11pt">/****************************************************************************/</font></span><font style="font-size: 11pt"><br><span style="color: ">/* assigns 'val to 'array[idx], after doing all the proper checks */</span></font></font><font style="font-size: 11pt"><br><font color="#dcdcdc"> </font><br><span style="color: "><font color="#c8c8c8">HCIMPL3</font></span><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#569cd6">void</font></span><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc"> JIT_Stelem_Ref_Portable</font><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc"> PtrArray</font><span style="color: "><font color="#b4b4b4">*</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">unsigned</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">idx</font></span><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc"> Object </font><span style="color: "><font color="#b4b4b4">*</font></span><span style="color: "><font color="#7f7f7f">val</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#b4b4b4"><span style="color: ">)</span><br><span style="color: ">{</span></font><br><font color="#dcdcdc">	FCALL_CONTRACT</font><span style="color: "><font color="#b4b4b4">;</font></span><br></font><font face="Consolas"><font color="#dcdcdc"> <br>	</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(!</font></span><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">)</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#57a64a">// ST: explicit check that the array is not null</font></span><br><font color="#dcdcdc">		FCThrowVoid</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">kNullReferenceException</font><span style="color: "><font color="#b4b4b4">);</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">}</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#7f7f7f">idx</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">&gt;=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">-&gt;</font></span><font color="#dcdcdc">GetNumComponents</font><span style="color: "><font color="#b4b4b4">())</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#57a64a">// ST: bounds check</font></span><br><font color="#dcdcdc">		FCThrowVoid</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">kIndexOutOfRangeException</font><span style="color: "><font color="#b4b4b4">);</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">}</font></span><br></font><font face="Consolas"><font color="#dcdcdc"> <br>	</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#7f7f7f">val</font></span><span style="color: "><font color="#b4b4b4">)</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">		MethodTable </font><span style="color: "><font color="#b4b4b4">*</font></span><font color="#dcdcdc">valMT </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">val</font></span><span style="color: "><font color="#b4b4b4">-&gt;</font></span><font color="#dcdcdc">GetMethodTable</font><span style="color: "><font color="#b4b4b4">();</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#57a64a">// ST: getting type of an array element</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">arrayElemTH</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">-&gt;</font></span><font color="#dcdcdc">GetArrayElementTypeHandle</font><span style="color: "><font color="#b4b4b4">();</font></span><br></font><font face="Consolas"><font color="#dcdcdc"> <br>		</font><span style="color: "><font color="#57a64a">// ST: g_pObjectClass is a pointer to EEClass instance of the System.Object</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#57a64a">// ST: if the element is object than the operation is successful.</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#c8c8c8">arrayElemTH</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">valMT</font><span style="color: "><font color="#b4b4b4">)</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">&amp;&amp;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">arrayElemTH</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">g_pObjectClass</font><span style="color: "><font color="#b4b4b4">))</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">			</font><span style="color: "><font color="#57a64a">// ST: need to check that the value is compatible with the element type</font></span><br><font color="#dcdcdc">			</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><span style="color: "><font color="#b4b4b4">::</font></span><font color="#dcdcdc">CastResult </font><span style="color: "><font color="#c8c8c8">result</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> ObjIsInstanceOfNoGC</font><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#7f7f7f">val</font></span><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#c8c8c8">arrayElemTH</font></span><span style="color: "><font color="#b4b4b4">);</font></span><br><font color="#dcdcdc">			</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><span style="color: "><font color="#c8c8c8">result</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">TypeHandle</font></span><span style="color: "><font color="#b4b4b4">::</font></span><font color="#dcdcdc">CanCast</font><span style="color: "><font color="#b4b4b4">)</font></span><br><font color="#dcdcdc">			</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">				</font><span style="color: "><font color="#57a64a">// ST: ArrayStoreCheck throws ArrayTypeMismatchException if the types are incompatible</font></span><br><font color="#dcdcdc">				</font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">HCCALL2</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">ArrayStoreCheck</font><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">Object</font><span style="color: "><font color="#b4b4b4">**)&amp;</font></span><span style="color: "><font color="#7f7f7f">val</font></span><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">PtrArray</font><span style="color: "><font color="#b4b4b4">**)&amp;</font></span><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">)</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#bd63c5">NULL</font></span><span style="color: "><font color="#b4b4b4">)</font></span><br><font color="#dcdcdc">				</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">					</font><span style="color: "><font color="#569cd6">return</font></span><span style="color: "><font color="#b4b4b4">;</font></span><br><font color="#dcdcdc">				</font><span style="color: "><font color="#b4b4b4">}</font></span><br><font color="#dcdcdc">			</font><span style="color: "><font color="#b4b4b4">}</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#b4b4b4">}</font></span><br></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> <br>		HCCALL2</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">JIT_WriteBarrier</font><span style="color: "><font color="#b4b4b4">,</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">(</font></span><font color="#dcdcdc">Object </font><span style="color: "><font color="#b4b4b4">**)&amp;</font></span><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">-&gt;</font></span><font color="#dcdcdc">m_Array</font><span style="color: "><font color="#b4b4b4">[</font></span><span style="color: "><font color="#7f7f7f">idx</font></span><span style="color: "><font color="#b4b4b4">],</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#7f7f7f">val</font></span><span style="color: "><font color="#b4b4b4">);</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">}</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#569cd6">else</font></span><br><font color="#dcdcdc">	</font><span style="color: "><font color="#b4b4b4">{</font></span><br><font color="#dcdcdc">		</font><span style="color: "><font color="#57a64a">// no need to go through write-barrier for NULL</font></span><br><font color="#dcdcdc">		ClearObjectReference</font><span style="color: "><font color="#b4b4b4">(&amp;</font></span><span style="color: "><font color="#7f7f7f">array</font></span><span style="color: "><font color="#b4b4b4">-&gt;</font></span><font color="#dcdcdc">m_Array</font><span style="color: "><font color="#b4b4b4">[</font></span><span style="color: "><font color="#7f7f7f">idx</font></span><span style="color: "><font color="#b4b4b4">]);</font></span><br><font color="#dcdcdc">	</font><font color="#b4b4b4"><span style="color: ">}</span><br></font></font><span style="color: "><font style="font-size: 11pt" color="#b4b4b4">}</font></span></font></pre>
<p>&nbsp; <h4>Increasing the performance by removing the type check</h4>
<p>Now we know that the CLR does under the hood to guarantee type safety for arrays of reference types. Every "write" to a array instance has an additional check that can be non-negligible if the array is used on the extremely hot path. But before getting into a wrong conclusion, let's check how expensive the check is. 
<p>To avoid the check, we could change the CLR or we can use a well-known trick: wrap an object into a struct: <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectWrapper</font></span><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span></font><font face="Consolas"><font color="#dcdcdc"> Instance;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> ObjectWrapper(</font><span style="color: "><font color="#569cd6">object</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> instance)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instance </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> instance;<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p>And compare the time for <strong>object[]</strong> and <strong>ObjectWrapper[]</strong>: <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">const</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> ArraySize </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">100_000</font></span><font color="#dcdcdc">;</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc">[] _objects </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc">[ArraySize];</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectWrapper</font></span><font color="#dcdcdc">[] _wrappers </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectWrapper</font></span><font color="#dcdcdc">[ArraySize];</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> _objectInstance </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc">();</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectWrapper</font></span><font color="#dcdcdc"> _wrapperInstanace </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectWrapper</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">object</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">());<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> WithCheck()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">for</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> i </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span><font color="#dcdcdc">; i </font><span style="color: "><font color="#b4b4b4">&lt;</font></span><font color="#dcdcdc"> _objects</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Length; i</font><span style="color: "><font color="#b4b4b4">++</font></span></font><font face="Consolas"><font color="#dcdcdc">)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _objects[i] </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> _objectInstance;<br>&nbsp;&nbsp;&nbsp; }<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> WithoutCheck()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">for</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> i </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span><font color="#dcdcdc">; i </font><span style="color: "><font color="#b4b4b4">&lt;</font></span><font color="#dcdcdc"> _objects</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Length; i</font><span style="color: "><font color="#b4b4b4">++</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _wrappers[i] </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> _wrapperInstanace;<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p>The results are: 
<p><font face="Consolas">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method |&nbsp;&nbsp;&nbsp;&nbsp; Mean |&nbsp;&nbsp;&nbsp;&nbsp; Error |&nbsp;&nbsp;&nbsp; StdDev |<br>-------------- |---------:|----------:|----------:|<br>&nbsp;&nbsp;&nbsp;&nbsp; WithCheck | 807.7 us | 15.871 us | 27.797 us |<br>&nbsp; WithoutCheck | 442.7 us |&nbsp; 9.371 us |&nbsp; 8.765 us |<br></font></p>
<p>
<p>Don't be confused with "almost 2x" performance difference. Even for the worst case, it takes less than a millisecond to assign 100K elements. The performance is extremely good. But the difference could be noticeable in the real world. 
<p>Many performance critical .NET applications use object pools. The pool allows to reuse a managed instance without creating a new one each time. This approach reduces the memory pressure and could have a very reasonable impact on the application performance. 
<p>An object pool can be implemented based on a concurrent data structure like <a href="http://referencesource.microsoft.com/#mscorlib/system/Collections/Concurrent/ConcurrentQueue.cs,18bcbcbdddbcfdcb">ConcurrentQueue</a> or based on a simple array. Here is a snippet from the <a href="http://source.roslyn.io/#Microsoft.CodeAnalysis/ObjectPool%25601.cs,40">object pool implementation</a> in the Roslyn codebase: <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">internal</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ObjectPool</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#b8d7a3">T</font></span><font color="#dcdcdc">&gt; </font><span style="color: "><font color="#569cd6">where</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b8d7a3">T</font></span><font color="#dcdcdc"> : </font><span style="color: "><font color="#569cd6">class</font></span><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; [</font><span style="color: "><font color="#4ec9b0">DebuggerDisplay</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#d69d85">"{Value,nq}"</font></span></font><font face="Consolas"><font color="#dcdcdc">)]<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Element</font></span><br></font><font face="Consolas"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">internal</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b8d7a3">T</font></span></font><font face="Consolas"><font color="#dcdcdc"> Value;<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Storage for the pool objects. The first item is stored in a dedicated field because we</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// expect to be able to satisfy most requests from it.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b8d7a3">T</font></span></font><font face="Consolas"><font color="#dcdcdc"> _firstItem;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Element</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">[] _items;<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// other members ommitted for brievity</font></span><br><font color="#dcdcdc">}</font></font></font></pre>
<p>The implementation manages an array of cached items but instead of using <strong>T[]</strong> the pool wraps <strong>T</strong> into the struct <strong>Element</strong> to avoid the check at the runtime. 
<p>Some time ago I've fixed an object pool in our application to get 30% performance improvement for the parsing phase. This was not due to the trick that I've described here, and was related to concurrent access of the pool. But the point is that object pools could be on the hot path of an application and even small performance improvements like one mentioned above could have a reasonable impact on the end to end performance. 


