<p><strong>The async series</strong>
<ul>
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">Dissecting the async methods in C#</a>. 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2018/01/11/extending-the-async-methods-in-c/">Extending the async methods in C#</a>. 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2018/01/25/the-performance-characteristics-of-async-methods/">The performance characteristics of async methods in C#</a>. 
<li><strong>One user scenario to rule them all</strong>.</li></ul>
<p>Almost every non-trivial behavior of the async methods in C# can be explained based on one user scenario: <strong>migration of the existing synchronous code to asynchronous should be as simple as possible</strong>. You should be able to add <code>async</code> keyword before a method's return type, add <code>Async</code> suffix to its name, add <code>await</code> keyword here and there in the method body to get a fully functional asynchronous method.
<p><a href="$One_Scenario_Figure_1[5].png"><img title="One_Scenario_Figure_1" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="One_Scenario_Figure_1" src="$One_Scenario_Figure_1_thumb[3].png" width="1481" height="831"></a>
<p>This "simple" scenario drastically affects the behavior of asynchronous methods in many different ways: from scheduling task's continuations to exception handling. The scenario sounds plausible and important but it made simplicity behind the async methods very deceptive.
<h4>Synchronization context</h4>
<p>UI development is one of the areas where the scenario mentioned above was especially important. Long-running operations in the UI thread make applications unresponsive and asynchronous programming was always considered a good fit there.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> buttonOk_ClickAsync(</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> sender, </font><span style="color: "><font color="#4ec9b0">EventArgs</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> args)<br>{<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Running.."</font></span><font color="#dcdcdc">; </font><span style="color: "><font color="#57a64a">// 1 -- UI Thread</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPricesForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">); </font><span style="color: "><font color="#57a64a">// 2 -- Usually non-UI Thread</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Result is: "</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> result; </font><span style="color: "><font color="#57a64a">//3 -- Should be UI Thread</font></span><br><font color="#dcdcdc">}</font></font></font></pre>
<p>The code looks very simple, but now we have a problem. Most UI frameworks have the restrictions that only a dedicate thread can change the UI elements. This means that line 3 would fail if a task's continuation is scheduled on a thread pool's thread. Luckily this issue was relatively old and starting from .NET Framework 2.0 the notion of <a href="https://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext(v=vs.80).aspx">Synchronization Contexts</a> was introduced.
<p>Each UI framework provides special utilities for marshaling work into a dedicated UI thread (or threads). Windows Forms relies on <a href="https://msdn.microsoft.com/en-us/library/system.windows.forms.control.invoke(v=vs.110).aspx"><code>Control.Invoke</code></a>, WPF - on <a href="https://msdn.microsoft.com/en-us/library/system.windows.threading.dispatcher.invoke(v=vs.110).aspx">Dispatcher.Invoke</a> and yet another framework may rely on something else. The concept is similar in all the cases, but the underlying details are different. Synchronization context abstracts away the differences and provides an API for running the code in a "special" context leaving the details to the derived types like <a href="http://referencesource.microsoft.com/#System.Windows.Forms/winforms/Managed/System/WinForms/WindowsFormsSynchronizationContext.cs,c7dfb662bbd6227d"><code>WindowsFormsSynchronizationContext</code></a>, <a href="http://referencesource.microsoft.com/#WindowsBase/Base/System/Windows/Threading/DispatcherSynchronizationContext.cs"><code>DispatcherSynchronizationContext</code></a> etc.
<p>To solve the thread-affinity problem the C# language authors decided to capture a current synchronization context at the beginning of the async methods and schedule all the continuations into the captured context. Now every block between <code>await</code>statements is executed in the UI thread that made the main scenario possible. But the solution introduced a whole bunch of other challenges.
<h4>Deadlocks</h4>
<p>Let's review a small and relatively simple piece of code. Are there any issues here?<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 11pt">// UI code</font></font></span><font style="font-size: 11pt"><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> buttonOk_Click(</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> sender, </font><span style="color: "><font color="#4ec9b0">EventArgs</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> args)<br>{<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Running.."</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPricesForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Result;<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Result is: "</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">+</font></span></font><font face="Consolas"><font color="#dcdcdc"> result;<br>}<br> </font><br><span style="color: "><font color="#57a64a">// StockPrices.dll</font></span><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPricesForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> symbol)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">Yield();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">;<br>}</font></font></font></pre>
<p><strong>The code will cause a deadlock</strong>. The UI thread starts an async operation and synchronously waits for the result. But the async method can't be finished because the second line of <code>GetStockPricesForAsync</code> is should run in the UI thread <strong>causing the deadlock</strong>.
<p>You may argue, that the issue is relatively easy to spot, and I'll agree with you. Any calls to <code>Task.Result</code> or <code>Task.Wait</code> should be banned from the UI code, but the problem still possible if the component that the UI code relies on, synchronously waits for an async operation's result:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 11pt">// UI code</font></font></span><font style="font-size: 11pt"><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> buttonOk_Click(</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> sender, </font><span style="color: "><font color="#4ec9b0">EventArgs</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> args)<br>{<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Running.."</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPricesForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Result;<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Result is: "</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">+</font></span></font><font face="Consolas"><font color="#dcdcdc"> result;<br>}<br> </font><br><span style="color: "><font color="#57a64a">// StockPrices.dll</font></span><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPricesForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> symbol)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// We know that the initialization step is very fast,</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// and completes synchronously in most cases,</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// let's wait for the result synchronously for "performance reasons".</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; InitializeIfNeededAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Wait();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromResult((</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b5cea8">42</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">);<br>}<br> </font><br><span style="color: "><font color="#57a64a">// StockPrices.dll</font></span><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc"> InitializeIfNeededAsync() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Delay(</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">);</font></font></font></pre>
<p>This code causes the deadlock as well. And now two "well-known" best practices for asynchronous programming in C# should make much more sense:
<ul>
<li>Do not block an async code via <code>Task.Wait()</code> or <code>Task.Result</code> and 
<li>Use <code>ConfigureAwait(false)</code> in a library code.</li></ul>
<p>The first advice should be clear already and we should have another section to explain the other one.
<h4>Configure "awaits"</h4>
<p>There are two reasons why the last example caused the deadlock: blocking call to <code>Task.Wait()</code> in <code>GetStockPricesForAsync</code> and the synchronization context implicitly used in the continuation inside <code>InitializeIfNeededAsync</code>. Even though C# authors discouraged use of blocking calls of async methods it was clear that there are plenty of cases when this may happen. To work-around a deadlock issue the C# language authors came up with the solution: <a href="http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs,9ca6b2f012ce7587"><code>Task.ConfigureAwait(continueOnCapturedContext:false)</code></a>.
<p>Besides a very strange name (that's absolutely obscure when you see a method call without named argument) it does its job: it forces the continuation to run without synchronization context.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPricesForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> symbol)<br>{<br>&nbsp;&nbsp;&nbsp; InitializeIfNeededAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Wait();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromResult((</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b5cea8">42</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">);<br>}<br> </font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc"> InitializeIfNeededAsync() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Delay(</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">ConfigureAwait(</font><span style="color: "><font color="#569cd6">false</font></span><font color="#dcdcdc">);</font></font></font></pre>
<p>In this case the continuation of <code>Task.Delay(1)</code> task (empty statement in this case), is scheduled in a thread pool's thread instead of the UI thread, causing the deadlock to go away.
<h4>Detaching the synchronization context</h4>
<p>I know that the <code>ConfigureAwait</code> is the de-facto way of dealing with this problem but I see a huge issue with it. Here is a small example:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPricesForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> symbol)<br>{<br>&nbsp;&nbsp;&nbsp; InitializeIfNeededAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Wait();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromResult((</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b5cea8">42</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>}<br> </font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeIfNeededAsync()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Initialize the cache field first</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc"> _cache</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">InitializeAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">ConfigureAwait(</font><span style="color: "><font color="#569cd6">false</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Do some work</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Delay(</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">);<br>}</font></font></font></pre>
<p>Can you see the problem here? We've used <code>ConfigureAwait(false)</code> so everything should be fine. But not necessarily.
<p><code>ConfigureAwait(false)</code> returns a custom awaiter called <a href="http://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/TaskAwaiter.cs,358"><code>ConfiguredTaskAwaitable</code></a> and we know that the awaiter is used only when the task is not finished synchronously. It means that if <code>_cache.InitializeAsync()</code> is completed synchronously we still could have a deadlock.
<p>To solve the deadlock problem <strong>every</strong> awaited task should be "decorated" with a <code>ConfigureAwait(false)</code> call. Annoying and error-prone.
<p>An alternative solution is to use <strong>a custom awaiter in every public method</strong> to detach the synchronization context from the asynchronous method:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> buttonOk_Click(</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> sender, </font><span style="color: "><font color="#4ec9b0">EventArgs</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> args)<br>{<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Running.."</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPricesForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Result;<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Result is: "</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">+</font></span></font><font face="Consolas"><font color="#dcdcdc"> result;<br>}<br> </font><br><span style="color: "><font color="#57a64a">// StockPrices.dll</font></span><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPricesForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> symbol)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// The rest of the method is guarantee won't have a current sync context.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Awaiters</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">DetachCurrentSyncContext();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// We can wait synchronously here and we won't have a deadlock.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; InitializeIfNeededAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">Wait();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">;<br>}</font></font></font></pre>
<p><code>Awaiters.DetachCurrentSyncContext</code> returns the following custom awaiter:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">DetachSynchronizationContextAwaiter</font></span><font color="#dcdcdc"> : </font><span style="color: "><font color="#b8d7a3">ICriticalNotifyCompletion</font></span><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><font color="#608b4e"><span style="color: ">///</span><span style="color: ">&nbsp;</span><span style="color: ">&lt;</span><span style="color: ">summary</span><span style="color: ">&gt;</span></font><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><font color="#608b4e"><span style="color: ">///</span><span style="color: "> Returns true if a current synchronization context is null.</span></font><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><font color="#608b4e"><span style="color: ">///</span><span style="color: "> It means that the continuation is called only when a current context</span></font><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><font color="#608b4e"><span style="color: ">///</span><span style="color: "> is presented.</span></font><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><font color="#608b4e"><span style="color: ">///</span><span style="color: ">&nbsp;</span><span style="color: ">&lt;/</span><span style="color: ">summary</span><span style="color: ">&gt;</span></font><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">bool</font></span><font color="#dcdcdc"> IsCompleted </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">SynchronizationContext</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Current </font><span style="color: "><font color="#b4b4b4">==</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">null</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> OnCompleted(</font><span style="color: "><font color="#4ec9b0">Action</font></span></font><font face="Consolas"><font color="#dcdcdc"> continuation)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">ThreadPool</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">QueueUserWorkItem(state </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span></font><font face="Consolas"><font color="#dcdcdc"> continuation());<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> UnsafeOnCompleted(</font><span style="color: "><font color="#4ec9b0">Action</font></span></font><font face="Consolas"><font color="#dcdcdc"> continuation)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">ThreadPool</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">UnsafeQueueUserWorkItem(state </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> continuation(), </font><span style="color: "><font color="#569cd6">null</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> GetResult() { }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">DetachSynchronizationContextAwaiter</font></span><font color="#dcdcdc"> GetAwaiter() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">this</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>}<br> </font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">static</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Awaiters</font></span><br></font><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">static</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">DetachSynchronizationContextAwaiter</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> DetachCurrentSyncContext()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">DetachSynchronizationContextAwaiter</font></span><font color="#dcdcdc">();<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p><code>DetachSynchronizationContextAwaiter</code> does the following: if the async method runs with non-null synchronization context, the awaiter detects this and schedules the continuation to the thread pool's thread. But if the async method runs without synchronization context <code>IsCompleted</code> property returns <code>true</code> and the continuation of the method runs synchronously.
<p>It means that there is close-to-0 overhead if the async method runs from the thread pool's thread and you pay only once to move the execution from the "UI"-thread to a thread pool's thread.
<p>Other benefits of this approach.
<ul>
<li><strong>The approach is less error prone.</strong> <code>ConfigureAwait(false)</code> only works when all the awaited tasks are decorated with it. If you forget just one, the deadlock could happen. In the custom awaiter case, you should remember one thing: all the public methods of your library should start with <code>Awaiters.DetachCurrentSyncContext()</code>. Still possible to mess up, but the likelihood is lower. 
<li><strong>The resulting code is more declarative and cleaner.</strong> In my opinion, a method with several <code>ConfigureAwait</code> calls is harder to read because of the noise, and the code is way less descriptive for a newcomer.</li></ul>
<h4>Exception handling</h4>
<p>What's the difference between this two cases:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#4ec9b0"><font style="font-size: 11pt">Task</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc"> mayFail </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromException(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ArgumentNullException</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">());<br> </font><br><span style="color: "><font color="#57a64a">// Case 1</font></span><br><span style="color: "><font color="#569cd6">try</font></span><font color="#dcdcdc"> { </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc"> mayFail; }</font><br><span style="color: "><font color="#569cd6">catch</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#4ec9b0">ArgumentException</font></span></font><font face="Consolas"><font color="#dcdcdc"> e)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Handle the error</font></span><br></font><font face="Consolas"><font color="#dcdcdc">}<br> </font><br><span style="color: "><font color="#57a64a">// Case 2</font></span><br><span style="color: "><font color="#569cd6">try</font></span><font color="#dcdcdc"> { mayFail</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Wait(); }</font><br><span style="color: "><font color="#569cd6">catch</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#4ec9b0">ArgumentException</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> e)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Handle the error</font></span><br><font color="#dcdcdc">}</font></font></font></pre>
<p>The first case does exactly what you'd expect -- handles the error, but the second one -- doesn't. TPL was designed for asynchronous and parallel programming and <code>Task</code>/<code>Task&lt;T&gt;</code> can represent a result of multiple operations. That's why <code>Task.Result</code>and <code>Task.Wait()</code> always throws an <code>AggregateException</code> that potentially contains more than one error.
<p>But our main scenario changes everything: the user should be able to add async/await without changing the error handling logic. This means that <code>await</code> statement should be different from <code>Task.Result</code>/<code>Task.Wait()</code>: it should unwrap one exception from the <code>AggregateException</code> instance. Today it picks the first one.
<p>Everything is fine if all the task-based methods are asynchronous and the tasks are not backed by a parallel computation. But this is not true all the time:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">try</font></font></span><font style="font-size: 11pt"><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; task1 </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromException&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ArgumentNullException</font></span></font><font face="Consolas"><font color="#dcdcdc">());<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; task2 </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromException&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">InvalidOperationException</font></span></font><font face="Consolas"><font color="#dcdcdc">());<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// await will rethrow the first exception</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">WhenAll(task1, task2);<br>}</font><br><span style="color: "><font color="#569cd6">catch</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#4ec9b0">Exception</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> e)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// ArgumentNullException. The second error is lost!</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(e</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetType());<br>}</font></font></font></pre>
<p><code>Task.WhenAll</code> returns a task that fails with two errors, but <code>await</code> statement extracts and propagates just the first one.
<p>There are two ways to solve this issue:
<ol>
<li>Observe individual tasks manually if you have an access to them or 
<li>Force TPL to wrap the exception into another <code>AggregateException</code>.</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">try</font></font></span><font style="font-size: 11pt"><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; task1 </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromException&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ArgumentNullException</font></span></font><font face="Consolas"><font color="#dcdcdc">());<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; task2 </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">FromException&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">InvalidOperationException</font></span></font><font face="Consolas"><font color="#dcdcdc">());<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// t.Result forces TPL to wrap the exception into AggregateException</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WhenAll(task1, task2)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">ContinueWith(t </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> t</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Result);<br>}</font><br><span style="color: "><font color="#569cd6">catch</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#4ec9b0">Exception</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> e)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// AggregateException</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(e</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetType());<br>}</font></font></font></pre>
<h4>Async void methods</h4>
<p>The task-based method returns a promise -- a token that can be used for processing the results in the future. If the task is lost the promise becomes unobservable by a user's code. The asynchronous operation that returns <code>void</code> makes the error case impossible to handle from the user's code. This makes them kind-of useless and, as we'll see in a moment -- dangerous. But our main scenario makes them necessary:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> buttonOk_ClickAsync(</font><span style="color: "><font color="#569cd6">object</font></span><font color="#dcdcdc"> sender, </font><span style="color: "><font color="#4ec9b0">EventArgs</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> args)<br>{<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Running.."</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPricesForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp; textBox</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Text </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"Result is: "</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> result;<br>}</font></font></font></pre>
<p>But will happen if <code>GetStockPricesForAsync</code> fail with an error? The unhandled exception of the async void method is marshaled to a current synchronization context triggering the same behavior as it was for the synchronous code (see <a href="http://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,1018">ThrowAsync method</a> at AsyncMethodBuilder.cs for more details). In Windows Forms an unhandled exception in the event handler triggers <a href="https://msdn.microsoft.com/en-us/library/system.windows.forms.application.threadexception(v=vs.110).aspx"><code>Application.ThreadException</code></a> event, for WPF - <a href="https://msdn.microsoft.com/en-us/library/system.windows.application.dispatcherunhandledexception.aspx?f=255&amp;MSPPError=-2147217396"><code>Application.DispatcherUnhandledException</code></a> event etc.
<p>But what if the async void method doesn't have a captured synchronization context? In this case, an unhandled exception will crash the app without an ability to recover from it. It won't trigger recoverable [<code>TaskScheduler.UnobservedTaskException</code>] event, it will trigger unrecoverable <a href="https://msdn.microsoft.com/en-us/library/system.appdomain.unhandledexception(v=vs.110).aspx"><code>AppDomain.UnhandledException</code></a> event and will close the app. This is intentional and this is what it should be.
<p>Now you should understand another famous best practice: <strong>Use async-void methods only for UI even handlers</strong>.
<p>Unfortunately, it is relatively easy to accidentally introduce an async void method without realizing it.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">static</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#b8d7a3">T</font></span><font color="#dcdcdc">&gt; ActionWithRetry&lt;</font><span style="color: "><font color="#b8d7a3">T</font></span><font color="#dcdcdc">&gt;(</font><span style="color: "><font color="#4ec9b0">Func</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#b8d7a3">T</font></span><font color="#dcdcdc">&gt;&gt; provider, </font><span style="color: "><font color="#4ec9b0">Action</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#4ec9b0">Exception</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">&gt; onError)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Calls 'provider' N times and calls 'onError' in case of an error.</font></span><br></font><font face="Consolas"><font color="#dcdcdc">}<br> </font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc">&gt; AccidentalAsyncVoid(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> fileName)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span></font><font face="Consolas"><font color="#dcdcdc"> ActionWithRetry(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; provider:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; () </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><br></font><font face="Consolas"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">File</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">ReadAllTextAsync(fileName);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Can you spot the issue?</font></span><br></font><font face="Consolas"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; onError:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc"> e </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><br></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">File</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteAllTextAsync(errorLogFile, e</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">ToString());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br>}</font></font></font></pre>
<p>It is very hard to tell just by looking at the lambda expression whether the function is task-based or async void and the error can easily sneak-in into your codebase even with a thorough code review.
<h4>Conclusion</h4>
<p>There is one user scenario -- simple migration from synchronous to asynchronous code for existing UI application -- that affected asynchronous programming in C# in so many ways:
<ul>
<li>The continuations of async methods are scheduled into a captured synchronization context that can cause deadlocks. 
<li>To avoid deadlocks all the async library code should be littered with <code>ConfigureAwait(false)</code> calls. 
<li><code>await task;</code> throws the first error making exception handling for parallel programming more complicated. 
<li>Async void methods were introduced for handling UI events but they can be used accidentally causing the application to crash in case of an unhandled exception.</li></ul>
<p>There is no such thing as a free lunch. Ease of use in one case can complicate other use cases drastically. Knowing the history of asynchronous programming in C# makes the weird behaviors less weird and should reduce the likelihood of an error in your asynchronous code.
