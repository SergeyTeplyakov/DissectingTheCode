<p>C# 7.2 got two very important features for high-performance scenarios -- the readonly structs and the <code>in</code> parameters. But to understand why this additions are so important and how they're related to each other we should look back in history. 
<p>As you probably know, the .NET ecosystem has two family of types -- the value types (a.k.a. structs) and the reference types (a.k.a. classes) (*). There are a plenty of differences between them but the main one is <strong>the semantics</strong>. The value types follow the value semantics: (1) two instances of a value type are equal if all the data members are equal and (2) the value type instance by default is passed around by value, i.e. by creating a copy of the original instance. The reference types, on the other hand, follow the "reference semantics": (1) two instances of a reference type are equal if they point to the same instance in the managed heap (**) and (2) a reference type instance is passed by reference, i.e. by passing the pointer to the original instance in the managed heap. 
<p>(*) The third category is managed references but for the sake of this discussion we can ignore them. (**) This behavior can be overriden by overriding <code>Equals</code> and <code>GetHashCode</code>. 
<h4>Readonly fields of the value types</h4>
<p>To enforce the value semantics of value types the C# compiler performs some actions that could be not obvious from the developer's point of view. Here is an example: <pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">internal</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ReadOnlyEnumerator</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">List</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;</font><span style="color: "><font color="#b4b4b4">.</font></span><span style="color: "><font color="#4ec9b0">Enumerator</font></span></font><font face="Consolas"><font color="#dcdcdc"> _enumerator;<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> ReadOnlyEnumerator(</font><span style="color: "><font color="#4ec9b0">List</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc">&gt; list)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Contract</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Requires(list</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Count </font><span style="color: "><font color="#b4b4b4">&gt;=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">1</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _enumerator </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> list</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">GetEnumerator();<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> PrintTheFirstElement()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _enumerator</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">MoveNext();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(_enumerator</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Current);<br>&nbsp;&nbsp;&nbsp; }<br></font></font><font face="Consolas"><font color="#dcdcdc"><br>}<br> <br></font></font><font face="Consolas"><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> roe </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ReadOnlyEnumerator</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">List</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt;{</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">,</font><span style="color: "><font color="#b5cea8">2</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">});<br>roe</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">PrintTheFirstElement();</font></font></font></pre>
<p>The output is not obvious: "0". 
<p>The <code>readonly</code> modifier has slightly different observable effects for the value types and for the reference types. A readonly field of a reference type is like a constant pointer: the compiler will make sure that the field is not reassigned outside the constructor even though the referenced object's state may change (if the referenced type is mutable). A readonly field of value type means that the value itself should be the same for the entire lifetime of the enclosing instance. To prevent any potential mutations, the compiler makes a defensive copy of the field each time a method or a property is used. 
<p>Under the hood <code>PrintTheFirstElement</code> does the following:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc"> PrintTheFirstElement_Decompiled()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Defensive copy</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> localEnumerator </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> _enumerator;<br>&nbsp;&nbsp;&nbsp; localEnumerator</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">MoveNext();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Defensive copy (2)</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; localEnumerator </font><span style="color: "><font color="#b4b4b4">=</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> _enumerator;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(localEnumerator</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Current);<br>}</font></font></font></pre>
<p>This is a real issue and the reason why <strong>mutable value types are evil</strong>. A couple of months back I spent a few hours debugging a similar issue caused by a readonly <a href="https://msdn.microsoft.com/en-us/library/system.threading.spinlock%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396"><code>SpinLock</code></a> field. 
<h4>The performance implications of the defensive copies</h4>
<p>Mutability is not the only problem. The defensive copies can affect performance even when the structs are immutable.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">long</font></span></font><font face="Consolas"><font color="#dcdcdc"> l1, l2, l3, l4;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> N { </font><span style="color: "><font color="#569cd6">get</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">; }<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> FairlyLargeStruct(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n) : </font><span style="color: "><font color="#569cd6">this</font></span><font color="#dcdcdc">() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> N </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> n;<br>}</font></font></font></pre>
<p>Let's see what the difference between <code>readonly</code> and non-<code>readonly</code> access of the field:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">private</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc"> _nonReadOnlyStruct </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">);</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc"> _readOnlyStruct </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">);</font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">[] _data </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Enumerable</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Range(</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">100_000</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">ToArray();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> AggregateForNonReadOnlyField()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">foreach</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#569cd6">in</font></span></font><font face="Consolas"><font color="#dcdcdc"> _data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result </font><span style="color: "><font color="#b4b4b4">+=</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> _nonReadOnlyStruct</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">N;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> result;<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> AggregateForReadOnlyField()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">foreach</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#569cd6">in</font></span></font><font face="Consolas"><font color="#dcdcdc"> _data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result </font><span style="color: "><font color="#b4b4b4">+=</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> _readOnlyStruct</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">N;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> result;<br>}</font></font></font><br></pre>
<p>The results are:<pre><code><p>                       Method |      Mean |    Error |    StdDev |
----------------------------- |----------:|---------:|----------:|
 AggregateForNonReadOnlyField |  87.92 us | 1.800 us |  3.677 us |
    AggregateForReadOnlyField | 148.29 us | 4.226 us | 12.460 us |
</p></code></pre>
<p>The significant difference in the results caused by a defensive copy that is happening each time the readonly field is used. You may have heard that the size of the struct should be relatively small to avoid the overhead of passing it around to other methods. But as you can see, you may get a performance hit even when a fairly large struct is stored in a readonly field and never passed to another method. 
<p>There are at least 3 solutions to this problem: 
<ol>
<li>Use fields instead of properties</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">long</font></span></font><font face="Consolas"><font color="#dcdcdc"> l1, l2, l3, l4;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> N;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> FairlyLargeStruct(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n) : </font><span style="color: "><font color="#569cd6">this</font></span><font color="#dcdcdc">() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> N </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> n;<br>}</font></font></font></pre>
<p>If the C# compiler sees an access to a <code>FairlyLargeStruct</code>'s field <code>N</code> via <code>readonly</code>variable, it won't create a defensive copy, because it knows that reading a field <code>N</code> is side effect free. This solution is not sustainable for a real world because <code>FairlyLargeStruct</code> could have methods as well, and even if there are no methods or properties today, it's just a matter of time when someone from your team will refactor the code to switch from fields to properties causing a performance regression. 
<ol start="2">
<li>Use non-readonly fields of <code>FairlyLargeStruct</code></li></ol>
<code><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 10pt">// Use non-readonly field to avoid redundant defensive copy on each field access</font></font></span><font style="font-size: 10pt"><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#57a64a">/*readonly*/</font></span><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc"> _fairlyLargeStruct;</font></font></font></pre></code>
<ol start="3">
<li>Use readonly structs</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">long</font></span></font><font face="Consolas"><font color="#dcdcdc"> l1, l2, l3, l4;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> N { </font><span style="color: "><font color="#569cd6">get</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">; }<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> FairlyLargeStruct(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n) : </font><span style="color: "><font color="#569cd6">this</font></span><font color="#dcdcdc">() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> N </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> n;<br>}</font></font></font></pre>
<h4>The readonly structs</h4>
<p>C# 7.2 allows a user to enforce immutability for a given struct by using the <code>readonly</code>modifier. As you may see in a moment it is good for performance but it is also very useful from a design perspective: readonly structs clearly carries the intention that the instance is immutable and can't be changed (without some tricks like reflection). 
<p>The <code>reaodnly</code> modifier enforces the following behavior: 
<ol>
<li>The compiler checks that the struct is indeed immutable and consists only of readonly fields and/or readonly properties (properties like <code>public int Foo {get; private set;}</code> are not readonly). 
<li>Allows the compiler to skip defensive copies in some contexts, like when a readonly field of such a struct is used.</li></ol>
<p>Here are the benchmark results for <code>readonly struct FairlyLargeStruct</code>:<pre><code><p>                       Method |     Mean |    Error |   StdDev |
----------------------------- |---------:|---------:|---------:|
 AggregateForNonReadOnlyField | 91.19 us | 1.811 us | 2.597 us |
    AggregateForReadOnlyField | 89.25 us | 1.775 us | 3.705 us |
</p></code></pre>
<h4>The <code>in</code>-modifier</h4>
<p>The very first version of the C# language had 3 ways of passing the arguments: by value (no modifier), by reference (with <code>ref</code> modifier) and as an output parameter (with <code>out</code> modifier) (***) 
<p>(***) Under the hood the CLR has only two options: passing by value and passing by reference. The <code>out</code> modifier is the same as <code>ref</code> modifier plus the compiler checks for definite assignment. 
<p>C# 7.2 introduces the third way of passing arguments: using <code>in</code>-modifier. 
<p>The <code>in</code>-modifier is a way to pass the argument via readonly reference. Under the hood, the argument is passed by reference with a special attribute (<code>System.Runtime.CompilerServices.IsReadOnlyAttribute</code>), and the compiler makes sure that the method does not modify the parameter.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> Foo(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> s)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Cannot assign to variable 'in string' because it is a readonly variable</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; s </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Empty;<br>}</font></font></font></pre>
<p>This simple language change has a large set of consequences. 
<ol>
<li>
<p>You can't create an overload that differs only by <code>in</code>, <code>ref</code>, <code>out</code>. This is expected, because the <code>in</code> modifier is the same the <code>ref</code>-modifier under the hood with some additional logic from the compiler.</p>
<li>
<p>You can't use the <code>in</code>-modifier for async methods and iterator blocks.</p></li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 10pt">// Async methods cannot have ref or out parameters</font></font></span><font style="font-size: 10pt"><br><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc"> ByInAsync(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Yield();</font></font></font><br></pre>
<p>This is expected as well because you can't use <code>ref</code>/<code>out</code> modifiers in these contexts as well. The restriction is just a side-effect of how <a href="$">async methods are implemented</a><a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/</a>. 
<ol start="3">
<li>You <strong>can</strong> pass a variable from a using block as an <code>in</code>-argument, even though it is impossible for <code>ref</code>/<code>out</code> parameters:</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">struct</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Disposable</font></span><font color="#dcdcdc"> : </font><span style="color: "><font color="#b8d7a3">IDisposable</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> Dispose() { }<br>}<br> </font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> DisposableSample()<br>{</font><br><span style="color: "><font color="#569cd6">using</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> d </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Disposable</font></span></font><font face="Consolas"><font color="#dcdcdc">())<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Ok</font></span><br></font><font face="Consolas"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; ByIn(d);<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Cannot use 'd' as a ref or out value because it is a 'using variable'</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">//ByRef(ref d);</font></span><br></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">}<br> </font><br><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> ByRef(</font><span style="color: "><font color="#569cd6">ref</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Disposable</font></span><font color="#dcdcdc"> disposable) { }</font><br><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> ByIn(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Disposable</font></span><font color="#dcdcdc"> disposable) { }</font></font></font></pre>
<p>This is already interesting. Apparently, the restriction that 'using variable' cannot be passed by reference is the compiler restriction, not the CLR one. And in this case, the restriction is removed because it is indeed safe to pass the variable as <code>in</code> argument. 
<ol start="4">
<li>Default values for <code>in</code>-parameters Here is another difference between <code>in</code>-parameters and <code>ref</code>/<code>out</code>: the <code>in</code>-parameter could have a default value:</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> ByIn(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">""</font></span><font color="#dcdcdc">) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> s</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Length;</font></font></font></pre>
<ol start="5">
<li>You <strong>can</strong> make an overload that differs only by <code>in</code> modifier:</li></ol><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> Foo(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> s</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Length;</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> Foo(</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> s</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Length;</font></font></font></pre>
<p>This case is tricky because the behavior is language-version-specific. For instance, in C# 7.2 (the first version that added this feature), it was impossible to call the second overload:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">string</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc"> s </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">Empty;<br>Foo(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc"> s);</font><br></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#57a64a"><span style="color: ">// The call is ambiguous between the following methods or properties: </span><br><span style="color: ">// 'WeirdOverload.Foo(in string)' and 'WeirdOverload.Foo(string)'</span></font><br><font color="#dcdcdc">Foo(s);</font></font></font></pre>
<p>But this behavior was <a href="https://github.com/dotnet/csharplang/issues/945">fixed</a> in C# 7.3 and now, <code>Foo(s)</code> is resolved to <code>Foo(string s)</code>. 
<p>But why the <code>in</code>-modifier is optional on the call-site? As we'll see in a moment, <code>in</code>-modifier can be very useful for high-performance scenarios, and this behavior simplifies the adoption of this feature:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> ByIn(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> s</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">Length;<br> </font><br></font><font face="Consolas"><br><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> s </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">string</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Empty;<br>ByIn(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc"> s); </font><span style="color: "><font color="#57a64a">// Works fine</font></span><br><font color="#dcdcdc">ByIn(s); </font></font><font face="Consolas"><font color="#57a64a"><span style="color: ">// Works fine as well!</span><br><span style="color: ">// Fail?!?! An expression cannot be used in this context because it may not be passed or returned by reference</span></font><br><font color="#dcdcdc">ByIn(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#d69d85">"some string"</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">);<br>ByIn(</font><span style="color: "><font color="#d69d85">"some string"</font></span><font color="#dcdcdc">); </font></font><span style="color: "><font style="font-size: 10pt" color="#57a64a">// Works fine!</font></span></font></pre>
<p>The behavior looks a bit inconsistent (all the other <code>ref</code>-like parameters should be passed using <code>in</code> or <code>out</code> keyword), the ability to omit the <code>in</code>-modifier makes a perfect sense to me (*****). Let suppose you've changed a library code to pass some fairly large struct using the <code>in</code>-modifier. You don't want every client of your library to change the call site of this method in order to benefit from your change. 
<p>(*****) What does not make sense to me at all is the error when the <code>in</code>-modifier is used with the literal. 
<p>As you can see the <code>in</code>-modifier is a bit trickier than you might think. Semantically it is just another form of "input" parameters, very similar to passing an argument by value. On the other hand the <code>in</code>-modifier is implemented as a <code>ref</code>-parameter making some scenarios like async methods, impossible. 
<p>But even with the existing restrictions, the new modifier is fairly useful because it helps to express the intent more clearly, and, as we'll see in a moment, it helps in terms of performance. 
<h4>Performance characteristics of the <code>in</code>-modifier</h4>
<p>The <code>in</code> parameters of value types are passed by reference, and that means that the cost of passing an argument is constant and doesn't depend on the size of the struct. This is a good news. But I have a bad news as well. 
<p>Let's change the original benchmark a little bit:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">struct</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">long</font></span></font><font face="Consolas"><font color="#dcdcdc"> l1, l2, l3, l4;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> N { </font><span style="color: "><font color="#569cd6">get</font></span></font><font face="Consolas"><font color="#dcdcdc">; }<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc"> FairlyLargeStruct(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n) : </font><span style="color: "><font color="#569cd6">this</font></span><font color="#dcdcdc">() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> N </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> n;<br>}<br> <br></font><br><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">[] _data </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Enumerable</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Range(</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">100_000</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">ToArray();<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> AggregatePassedByValue()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> DoAggregate(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#b5cea8">42</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> DoAggregate(</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span></font><font face="Consolas"><font color="#dcdcdc"> largeStruct)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">foreach</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#569cd6">in</font></span></font><font face="Consolas"><font color="#dcdcdc"> _data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result </font><span style="color: "><font color="#b4b4b4">+=</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> largeStruct</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">N;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> result;<br>&nbsp;&nbsp;&nbsp; }<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> AggregatePassedByIn()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> DoAggregate(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#b5cea8">42</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> DoAggregate(</font><span style="color: "><font color="#569cd6">in</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">FairlyLargeStruct</font></span></font><font face="Consolas"><font color="#dcdcdc"> largeStruct)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> result </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">0</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">foreach</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#569cd6">in</font></span></font><font face="Consolas"><font color="#dcdcdc"> _data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result </font><span style="color: "><font color="#b4b4b4">+=</font></span><font color="#dcdcdc"> n </font><span style="color: "><font color="#b4b4b4">+</font></span><font color="#dcdcdc"> largeStruct</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">N;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> result;<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p>Note, that <code>FairlyLargeStruct</code> struct is a normal struct, not a readonly one. Here are the results:<pre><code><p>                 Method |      Mean |     Error |    StdDev |
----------------------- |----------:|----------:|----------:|
 AggregatePassedByValue |  71.24 us | 0.3150 us | 0.2278 us |
    AggregatePassedByIn | 124.02 us | 3.2885 us | 9.6963 us |
</p></code></pre>
<p>Remember I've mentioned that the <code>in</code> parameters are similar to the readonly fields? To make sure that the parameter's value stays the same the compiler make a defensive copy of the parameter every time a method/property is used. If the struct is readonly then the compiler removes the defensive copy the same way as it does for readonly fields. 
<p>It means that <strong>you should never pass a non-readonly struct as <code>in</code> parameter</strong>. It almost always will make the performance worse. Yes, the argument passing is cheaper, but once the parameter is used, the defensive copy will nullify the benefits or will make the performance worse. It could make sense if the struct is a C-like struct with a bunch of public fields and everyone in the team is aware that changing fields to properties would have a drastic performance impact on the application. But in this case, I would suggest passing the struct by reference instead. 
<h4>Conclusion</h4>
<ul>
<li>The readonly structs are very useful from the design and the performance points of view. 
<li>If the size of a readonly struct is bigger than <code>IntPtr.Size</code> you should pass it as an <code>in</code>-parameter for performance reasons. 
<li>You may consider using the <code>in</code>-parameters for reference types to express your intent more clearly. 
<li>You should never use a non-readonly struct as the <code>in</code> parameters because it may negatively affect performance and could lead to an obscure behavior if the struct is mutable.</li></ul>