<p>In the last two blog posts we've covered <a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">the internals of async methods</a> in C# and then we looked at <a href="https://blogs.msdn.microsoft.com/seteplia/2018/01/11/extending-the-async-methods-in-c/">the extensibility points</a> the C# compiler provides to adjust the behavior of async methods. Today we're going to explore the performance characteristics of async methods. 
<p>As you should already know from the <a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">first post of the series</a>, the compiler does a lot of transformations to make asynchronous programming experience very similar to a synchronous one. But to do that the compiler creates a state machine instance, pass it around to an async method builder, that calls task awaiter etc. Obviously, all of that logic has its own cost, but how much do we pay? 
<p>Back in pre-TPL days, asynchronous operations usually were fairly coarse-grained so the overhead of an asynchronous operation was likely negligible. But today even relatively simple application could have hundreds if not thousands asynchronous operations per second. The TPL was designed with this workload in mind but it's not magic, it has some overhead. 
<p>To measure an overhead of async methods will use a slightly modified example that we used in the first blog post.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">StockPrices</font></span><br></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">const</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> Count </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b5cea8">100</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">List</font></span><font color="#dcdcdc">&lt;(</font><span style="color: "><font color="#569cd6">string</font></span><font color="#dcdcdc"> name, </font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc"> price)&gt; _stockPricesCache;<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Async version</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPriceForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> companyId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> DoGetPriceFromCache(companyId);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Sync version that calls async init</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc"> GetStockPriceFor(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> companyId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeMapIfNeededAsync()</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">GetResult();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> DoGetPriceFromCache(companyId);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Purely sync version</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc"> GetPriceFromCacheFor(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> companyId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeMapIfNeeded();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> DoGetPriceFromCache(companyId);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc"> DoGetPriceFromCache(</font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> name)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">foreach</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> kvp </font><span style="color: "><font color="#569cd6">in</font></span></font><font face="Consolas"><font color="#dcdcdc"> _stockPricesCache)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (kvp</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">name </font><span style="color: "><font color="#b4b4b4">==</font></span></font><font face="Consolas"><font color="#dcdcdc"> name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> kvp</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">price;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">throw</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">InvalidOperationException</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#d69d85">$"Can't find price for '</font></span><font color="#dcdcdc">{name}</font><span style="color: "><font color="#d69d85">'."</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; [</font><span style="color: "><font color="#4ec9b0">MethodImpl</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#b8d7a3">MethodImplOptions</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">NoInlining)]<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeeded()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Similar initialization logic.</font></span><br></font><font face="Consolas"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">private</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (_stockPricesCache </font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">null</font></span></font><font face="Consolas"><font color="#dcdcdc">)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Delay(</font><span style="color: "><font color="#b5cea8">42</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Getting the stock prices from the external source.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Generate 1000 items to make cache hit somewhat expensive</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _stockPricesCache </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Enumerable</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Range(</font><span style="color: "><font color="#b5cea8">1</font></span></font><font face="Consolas"><font color="#dcdcdc">, Count)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Select(n </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> (name: n</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">ToString(), price: (</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc">)n))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">ToList();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _stockPricesCache</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Add((name: </font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">, price: </font><span style="color: "><font color="#b5cea8">42</font></span><font color="#dcdcdc">));<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p><code>StockPrices</code> class populates the cache with the stock prices from an external source and provides an API to query it. The main difference from the first post's example is the switch from the dictionary to a list of prices. To measure the overhead of different forms of async methods compared to synchronous ones the operation itself should do at least some work and linear search of stock prices models this aspect. 
<p><code>GetPricesFromCache</code> is intentionally built using a plain loop to avoid any allocations. 
<h4>Synchronous vs. Task-based asynchronous versions</h4>
<p>In the first benchmark, we comparing async method that calls async initialization method (<code>GetStockPriceForAsync</code>), a synchronous method that calls asynchronous initialization method (<code>GetStockPriceFor</code>) and synchronous method that calls synchronous initialization method.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">readonly</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">StockPrices</font></span><font color="#dcdcdc"> _stockPrices </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">StockPrices</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc">();<br> </font><br><span style="color: "><font color="#569cd6">public</font></span></font><font face="Consolas"><font color="#dcdcdc"> SyncVsAsyncBenchmark()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Warming up the cache</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">GetResult();<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc"> GetPricesDirectlyFromCache()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetPriceFromCacheFor(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">(Baseline </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">true</font></span><font color="#dcdcdc">)]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc"> GetStockPriceFor()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceFor(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> GetStockPriceForAsync()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPrices</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetResult();<br>}</font></font></font></pre>
<p>The results are: <pre><code><p>                     Method |     Mean | Scaled |  Gen 0 | Allocated |
--------------------------- |---------:|-------:|-------:|----------:|
 GetPricesDirectlyFromCache | 2.177 us |   0.96 |      - |       0 B |
           GetStockPriceFor | 2.268 us |   1.00 |      - |       0 B |
      GetStockPriceForAsync | 2.523 us |   1.11 | 0.0267 |      88 B |
</p></code></pre>
<p>This data is already very interesting: 
<ul>
<li>The async method is rather fast. <code>GetPricesForAsync</code> completes synchronously in this benchmark and it's about 15% (*) slower than the purely synchronous method. 
<li>The synchronous <code>GetPricesFor</code> method that calls asynchronous <code>InitializeMapIfNeededAsync</code> method has even lower overhead, but the most surprising thing that it does <strong>not allocate at all</strong> (Allocated column in the previous table has 0 for both <code>GetPricesDirectlyFromCache</code> and for <code>GetStockPriceFor</code>).</li></ul>
<p>(*) Of course, you can't say that the overhead of async machinery when the async method runs synchronously is 15% for all possible cases. The percentage is very specific to the amount of work the method is doing. Measuring a pure method call overhead for async method (that does nothing) with a synchronous method (that does nothing) will show a huge difference. The idea of this benchmark is to show that the overhead of an async method that does a relatively small amount of work is moderate. 
<p>How is it possible that the call to <code>InitializeMapIfNeededAsync</code> caused no allocations at all? I've mentioned in the first post of the series that the async method <em>have to</em> allocate at least one object in the managed head - the task instance itself. Let's explore this aspect. 
<h4>Optimization #1. Cache the task instance if possible</h4>
<p>The answer to the previous question is very simple: <strong><code>AsyncMethodBuilder</code> uses a single task instance for every successfully completed async operations</strong>. An async method that returns <code>Task</code> relies on <code>AsyncMethodBuilder</code> that has the following logic in <a href="http://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/AsyncMethodBuilder.cs,378"><code>SetResult</code></a> method:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 11pt">// AsyncMethodBuilder.cs from mscorlib</font></font></span><font style="font-size: 11pt"><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> SetResult()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// I.e. the resulting task for all successfully completed</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// methods is the same -- s_cachedCompleted.</font></span><br></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; m_builder</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">SetResult(s_cachedCompleted);<br>}</font></font></font></pre>
<p><code>SetResult</code> method is called only for async methods that completed successfully and <strong>the successful result for every <code>Task</code>-based method can be easily shared</strong>. We can even observe this behavior with the following test:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#dcdcdc"><font style="font-size: 11pt">[</font></font><font style="font-size: 11pt"><span style="color: "><font color="#4ec9b0">Test</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> AsyncVoidBuilderCachesResultingTask()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> t1 </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> Foo();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> t2 </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> Foo();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Assert</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">AreSame(t1, t2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc"> Foo() { }<br>}</font></font></font></pre>
<p>But this is not the only optimization that could happen. <code>AsyncTaskMethodBuilder&lt;T&gt;</code> does a similar optimization: it caches tasks for <code>Task&lt;bool&gt;</code> and for some other primitive types. For instance, it caches all the default values for a bunch of integral types and has a special cache for <code>Task&lt;int&gt;</code> for the values in range [-1; 9) (see <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> for more details). 
<p>The following test proofs that this is indeed the case:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#dcdcdc"><font style="font-size: 11pt">[</font></font><font style="font-size: 11pt"><span style="color: "><font color="#4ec9b0">Test</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> AsyncTaskBuilderCachesResultingTask()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// These values are cached</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Assert</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">AreSame(Foo(</font><span style="color: "><font color="#b4b4b4">-</font></span><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">), Foo(</font><span style="color: "><font color="#b4b4b4">-</font></span><span style="color: "><font color="#b5cea8">1</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Assert</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">AreSame(Foo(</font><span style="color: "><font color="#b5cea8">8</font></span><font color="#dcdcdc">), Foo(</font><span style="color: "><font color="#b5cea8">8</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// But these are not</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Assert</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">AreNotSame(Foo(</font><span style="color: "><font color="#b5cea8">9</font></span><font color="#dcdcdc">), Foo(</font><span style="color: "><font color="#b5cea8">9</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Assert</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">AreNotSame(Foo(</font><span style="color: "><font color="#569cd6">int</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">MaxValue), Foo(</font><span style="color: "><font color="#569cd6">int</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">MaxValue));<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; Foo(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> n) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> n;<br>}</font></font></font></pre>
<p>You <strong>should not rely on this behavior too much</strong> but its good to know that the language and framework authors try their best to fine-tune performance in every possible way. Caching a task is a common optimization pattern that is used in other places as well. For instance, new <a href="https://github.com/dotnet/corefx/blob/12e6bb4a7f525323b827e3ee0d26bdd2691c6a34/src/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs#L27"><code>Socket</code></a> implementation in <a href="https://github.com/dotnet/corefx/">corefx repo</a> heavily relies on this optimization and uses <a href="https://github.com/dotnet/corefx/blob/12e6bb4a7f525323b827e3ee0d26bdd2691c6a34/src/System.Net.Sockets/src/System/Net/Sockets/Socket.Tasks.cs#L575">cached tasks</a> whenever possible. 
<h4>Optimization #2: use <code>ValueTask</code></h4>
<p>The optimization mentioned above works only in a few cases. Instead of relying on it, we can use <code>ValueTask&lt;T&gt;</code> (**): a special task-like value type that will not allocate if the method completes synchronously. 
<p><code>ValueTask&lt;T&gt;</code> is effectively a discriminated union of <code>T</code> and <code>Task&lt;T&gt;</code>: if the "value task" is completed then the underlying value would be used. If the underlying promise is not finished yet, then the task would be allocated. 
<p>This special type helps to avoid unnecessary heap allocations when the operation completes synchronously. To use <code>ValueTask&lt;T&gt;</code> we just need to change the return type of <code>GetStockPriceForAsync</code> from <code>Task&lt;decimal</code> to <code>ValueTask&lt;decimal&gt;</code>:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPriceForAsync(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> companyId)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> InitializeMapIfNeededAsync();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> DoGetPriceFromCache(companyId);<br>}</font></font></font></pre>
<p>And now we can measure the difference with this additional benchmark:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#dcdcdc"><font style="font-size: 11pt">[</font></font><font style="font-size: 11pt"><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> GetStockPriceWithValueTaskAsync_Await()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPricesThatYield</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceValueTaskForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetResult();<br>}</font></font></font></pre>

<pre>
<code>                          Method |     Mean | Scaled |  Gen 0 | Allocated |
-------------------------------- |---------:|-------:|-------:|----------:|
      GetPricesDirectlyFromCache | 1.260 us |   0.90 |      - |       0 B |
                GetStockPriceFor | 1.399 us |   1.00 |      - |       0 B |
           GetStockPriceForAsync | 1.552 us |   1.11 | 0.0267 |      88 B |
<strong> GetStockPriceWithValueTaskAsync | 1.519 us |   1.09 |      - |       0 B |</strong>
</code>
</pre>
<p>As you may see the <code>ValueTask</code>-based version is just a bit faster than the <code>Task</code>-based version. The main difference is the lack of heap allocations. We'll discuss in a moment whether it worth doing this switch or not, but before that, I would like cover one tricky optimization. 
<h4>Optimization #3: avoid async machinery on a common path</h4>
<p>If you have an extremely widely used async method and you want to reduce the overhead even more, you may consider the following optimization: you can remove <code>async</code> modifier, check the task's state inside the method and perform the entire operation synchronously without dealing with async machinery at all. 
<p>Sounds complicated? Let's look at the example.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPriceWithValueTaskAsync_Optimized(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> companyId)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> task </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Optimizing for acommon case: no async machinery involved.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (task</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">IsCompleted)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc">&gt;(DoGetPriceFromCache(companyId));<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> DoGetStockPricesForAsync(task, companyId);<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; DoGetStockPricesForAsync(</font><span style="color: "><font color="#4ec9b0">Task</font></span><font color="#dcdcdc"> initializeTask, </font><span style="color: "><font color="#569cd6">string</font></span></font><font face="Consolas"><font color="#dcdcdc"> localCompanyId)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> initializeTask;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> DoGetPriceFromCache(localCompanyId);<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p>In this case, the method <code>GetStockPriceWithValueTaskAsync_Optimized</code> does not have <code>async</code> modifier and when it gets the task from <code>InitializeMapIfNeededAsync</code>method it checks whether the task is completed or not. If the task is completed, it just calls <code>DoGetPriceFromCache</code> to get the results immediately. But if the initialization task is still running, it calls the local function to await the results. 
<p>Using a local function is not the only option but one of the simplest one. But there is a caveat. The most natural implementation of the local function would capture an enclosing state: the local variable and the argument:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPriceWithValueTaskAsync_Optimized2(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> companyId)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Oops! This will lead to a closure allocation at the beginning of the method!</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> task </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Optimizing for acommon case: no async machinery involved.</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (task</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">IsCompleted)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc">&gt;(DoGetPriceFromCache(companyId));<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font><font face="Consolas"><font color="#dcdcdc"> DoGetStockPricesForAsync();<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc">&gt; DoGetStockPricesForAsync()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> task;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> DoGetPriceFromCache(companyId);<br>&nbsp;&nbsp;&nbsp; }<br>}</font></font></font></pre>
<p>But unfortunately, due to <a href="https://github.com/dotnet/roslyn/issues/18946">a compiler bug</a> this code would allocate a closure even when the method completes on a common path. Here how this method looks under the hood:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">public</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTask</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">decimal</font></span><font color="#dcdcdc">&gt; GetStockPriceWithValueTaskAsync_Optimized(</font><span style="color: "><font color="#569cd6">string</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> companyId)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> closure </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">__DisplayClass0_0</font></span></font><font face="Consolas"><font color="#dcdcdc">()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __this </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">this</font></span></font><font face="Consolas"><font color="#dcdcdc">,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; companyId </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> companyId,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync()<br>&nbsp;&nbsp;&nbsp; };<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (closure</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">task</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">IsCompleted)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">...</font></span><br></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// The rest of the code</font></span><br><font color="#dcdcdc">}</font></font></font></pre>
<p>As we discussed in <a href="https://blogs.msdn.microsoft.com/seteplia/2017/10/03/dissecting-the-local-functions-in-c-7/">"Dissecting the local functions in C#"</a> the compiler uses the shared closure instance for all locals/arguments in the given scope. So this code generation kind-of makes sense, but it makes the whole fight with heap allocations useless. 
<p><strong>TIP</strong> <em>This optimization is very tricky. The benefits are very small and even you write the original local function <strong>right</strong> you can easily make the change in the future and accidentally capture an enclosing state causing a heap allocation. You still may use the optimization if you work on a highly reusable library like BCL on a method that will be definitely used on hot paths. </em>
<h4>The overhead of awaiting the task</h4>
<p>So far we've covered only one specific case: the overhead of an async method that completes synchronously. This was intentional. "Smaller" the async method is, more visible the overhead would be for its overall performance. Fine-grained async methods tend to do less work and tend to complete synchronously more often. And we tend to call them more frequently. 
<p>But we should know the overhead of the async machinery when a method "awaits" a non-completed task. To measure this overhead we change <code>InitializeMapIfNeededAsync</code> to call <code>Task.Yield()</code> even when the cache is initialized:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 11pt">private</font></font></span><font style="font-size: 11pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">async</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> InitializeMapIfNeededAsync()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (_stockPricesCache </font><span style="color: "><font color="#b4b4b4">!=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">null</font></span></font><font face="Consolas"><font color="#dcdcdc">)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">await</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Task</font></span><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Yield();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc">;<br>&nbsp;&nbsp;&nbsp; }<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Old initialization logic</font></span><br><font color="#dcdcdc">}</font></font></font></pre>
<p>Let's extend our performance benchmark suite with the following methods:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><font color="#dcdcdc"><font style="font-size: 11pt">[</font></font><font style="font-size: 11pt"><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font></font><font style="font-size: 11pt"><font face="Consolas"><font color="#dcdcdc"> GetStockPriceFor_Await()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPricesThatYield</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceFor(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font><font face="Consolas"><font color="#dcdcdc"> GetStockPriceForAsync_Await()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPricesThatYield</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">GetResult();<br>}<br> <br>[</font><span style="color: "><font color="#4ec9b0">Benchmark</font></span><font color="#dcdcdc">]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">decimal</font></span></font></font><font face="Consolas"><font style="font-size: 11pt"><font color="#dcdcdc"> GetStockPriceWithValueTaskAsync_Await()<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> _stockPricesThatYield</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetStockPriceValueTaskForAsync(</font><span style="color: "><font color="#d69d85">"MSFT"</font></span><font color="#dcdcdc">)</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetAwaiter()</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetResult();<br>}</font></font></font></pre><pre><code><p>                                    Method |      Mean | Scaled |  Gen 0 |  Gen 1 | Allocated |
------------------------------------------ |----------:|-------:|-------:|-------:|----------:|
                          GetStockPriceFor |  2.332 us |   1.00 |      - |      - |       0 B |
                     GetStockPriceForAsync |  2.505 us |   1.07 | 0.0267 |      - |      88 B |
           GetStockPriceWithValueTaskAsync |  2.625 us |   1.13 |      - |      - |       0 B |
                    GetStockPriceFor_Await |  6.441 us |   2.76 | 0.0839 | 0.0076 |     296 B |
               GetStockPriceForAsync_Await | 10.439 us |   4.48 | 0.1577 | 0.0122 |     553 B |
     GetStockPriceWithValueTaskAsync_Await | 10.455 us |   4.48 | 0.1678 | 0.0153 |     577 B |
</p></code></pre>
<p>As we can see the difference is way more visible, both in terms of speed and memory. Here is a short explanation of the results. 
<ul>
<li>Each 'await' operation for an unfinished task takes about 4us and allocates almost 300B (**) per invocation. This explains why <code>GetStockPriceFor</code> is almost twice as fast than <code>GetStockPriceForAsync</code> and why its allocate less memory. 
<li>A <code>ValueTask</code>-based async method is a bit slower than a <code>Task</code>-based async method when the method is not completed synchronously. The state machine of a <code>ValueTask&lt;T&gt;</code>-based method needs to keep more data compared to a state machine for a <code>Task&lt;T&gt;</code>-based method.</li></ul>
<p>(**) It depends on the platform (x64 vs. x86), and a number of local variables/arguments of the async method. 
<h4>Async methods performance 101</h4>
<ul>
<li>If the async method completes synchronously the performance overhead is fairly small. 
<li>If the async method completes synchronously the following memory overhead will occur: for <code>async Task</code> methods there is no overhead, for <code>async Task&lt;T&gt;</code>methods the overhead is 88 bytes per operation (on x64 platform). 
<li><code>ValueTask&lt;T&gt;</code> can remove the overhead mentioned above for async methods that complete synchronously. 
<li>A <code>ValueTask&lt;T&gt;</code>-based async method is a bit faster than a <code>Task&lt;T&gt;</code>-based method if the method completes synchronously and a bit slower otherwise. 
<li>A performance overhead of async methods that await non-completed task is way more substantial (~300 bytes per operation on x64 platform).</li></ul>
<p>And, as always, measure first. If you see that an async operation causes a performance problem, you may switch from <code>Task&lt;T&gt;</code> to <code>ValueTask&lt;T&gt;</code>, cache a task or make a common execution path synchronous if possible. But you may also try to make your async operations coarser grained. This can improve performance, simplify debugging and overall make your code easier to reason. <strong>Not every small piece of code has to be asynchronous</strong>. 
<h4>Additional references</h4>
<ul>
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/">Dissecting the async methods in C#</a> 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2018/01/11/extending-the-async-methods-in-c/">Extending the async methods in C#</a> 
<li><a href="https://github.com/dotnet/corefx/issues/4708#issuecomment-160658188">Stephen Toub's comment about <code>ValueTask</code>'s usage scenarios</a> 
<li><a href="https://blogs.msdn.microsoft.com/seteplia/2017/10/03/dissecting-the-local-functions-in-c-7/">"Dissecting the local functions in C#"</a></li></ul>