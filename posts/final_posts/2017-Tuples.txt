<p><a href="http://referencesource.microsoft.com/#mscorlib/system/tuple.cs,9124c4bea9ab0199"><code>System.Tuple</code></a> types were introduced in .NET 4.0 with two significant drawbacks: (1) tuple types are classes and (2) there was no language support for constructing/deconstructing them. To solve these issues, C# 7 introduces new language feature as well as a new family of types (*).
<p>Today, if you need to glue together two values to return them from a function or put two values in a hash set you can use <code>System.ValueTuple</code> types and construct them using a handy syntax:</p><pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 10pt">// Constructing the tuple instance</font></font></span><font style="font-size: 10pt"><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> tpl </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><br><span style="color: "><font color="#57a64a">// Using tuples with a dictionary</font></span><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> d </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Dictionary</font></span><font color="#dcdcdc">&lt;(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> y), (</font><span style="color: "><font color="#569cd6">byte</font></span><font color="#dcdcdc"> a, </font><span style="color: "><font color="#569cd6">short</font></span></font><font face="Consolas"><font color="#dcdcdc"> b)&gt;();<br> </font><br><span style="color: "><font color="#57a64a">// Tuples with different names are compatible</font></span><br><font color="#dcdcdc">d</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Add(tpl, (a: </font><span style="color: "><font color="#b5cea8">3</font></span><font color="#dcdcdc">, b: </font><span style="color: "><font color="#b5cea8">4</font></span></font><font face="Consolas"><font color="#dcdcdc">));<br> </font><br><span style="color: "><font color="#57a64a">// Tuples have value semantic</font></span><br><span style="color: "><font color="#569cd6">if</font></span><font color="#dcdcdc"> (d</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">TryGetValue((</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span><font color="#dcdcdc">), </font><span style="color: "><font color="#569cd6">out</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">var</font></span></font><font face="Consolas"><font color="#dcdcdc"> r))<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Deconstructing the tuple ignoring the first element</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">_</font></span><font color="#dcdcdc">, b) </font><span style="color: "><font color="#b4b4b4">=</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> r;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Using named syntax as well as predefined name</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(</font><span style="color: "><font color="#d69d85">$"a: </font></span><font color="#dcdcdc">{r</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">a}</font><span style="color: "><font color="#d69d85">, b: </font></span><font color="#dcdcdc">{r</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Item2}</font><span style="color: "><font color="#d69d85">"</font></span><font color="#dcdcdc">);<br>}</font></font></font></pre>
<p>(*) <code>System.ValueTuple</code> types are introduced in .NET Framework 4.7. But you still can use the feature and target lower framework versions, in this case, you have to reference a special nuget package: <a href="https://www.nuget.org/packages/System.ValueTuple/">System.ValueTuple</a>.
<ul>
<li>Tuple declaration syntax is similar to function parameter declaration: <code>(Type1 name1, Type2 name2)</code>. 
<li>Tuple construction syntax is similar to argument construction: <code>(value1, optionalName: value2)</code>. 
<li>Two tuples with the same element types but with different names are compatible (**): <code>(int a, int b) = (1, 2)</code>. 
<li>Tuples have value semantic: <code>(1,2).Equals((a: 1, b: 2))</code> and <code>(1,2).GetHashCode() == (1,2).GetHashCode()</code> are both <code>true</code>. 
<li>Tuples do not support <code>==</code> and <code>!=</code>. There is a pending discussion about it on github: <a href="https://github.com/dotnet/csharplang/issues/190">"Support for == and != on tuple types"</a>. 
<li>Tuples can be "deconstructed" but only into "variable declaration" but not into "out var" or in the <code>case</code> block: <code>var (x, y) = (1,2)</code> - OK, <code>(var x, int y) = (1,2)</code> - OK, <code>dictionary.TryGetValue(key, out var (x, y))</code> - not OK, <code>case var (x, y): break;</code> - not OK. 
<li>Tuples are mutable: <code>(int a, int b) x (1,2); x.a++;</code>. 
<li>Tuple elements can be accessed by the name (if provided) or via generic names like <code>Item1</code>, <code>Item2</code> etc.</li></ul>
<p>(**) We'll see when this is not the case in a moment.
<h4>Tuple element names</h4>
<p>Lack of user-defined names makes <code>System.Tuple</code> types not very useful. I can use <code>System.Tuple</code> as an implementation detail of a small method but if I need to pass it around I prefer a named type with descriptive property names. New tuple feature addresses this issue quite elegantly: you can specify names for tuple elements and unlike anonymous classed these names are available even across different assemblies.
<p>The C# compiler emits a special attribute <a href="http://source.roslyn.io/#System.Runtime/System.Runtime.cs,3832"><code>TupleElementNamesAttribute</code></a>(***) for each tuple type used in a method signature:
<p>(***) The attribute <code>TupleElementNamesAttribute</code> is special and can't be used directly in the user code. The compiler emits an error if you try to use it.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> a, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> b) Foo1((</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> c, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> d) a) </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc"> a;<br> <br>[</font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc">: </font><span style="color: "><font color="#4ec9b0">TupleElementNames</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">[] { </font><span style="color: "><font color="#d69d85">"a"</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#d69d85">"b"</font></span><font color="#dcdcdc"> })]</font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">ValueTuple</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc">&gt; Foo(<br>&nbsp;&nbsp;&nbsp; [</font><span style="color: "><font color="#4ec9b0">TupleElementNames</font></span><font color="#dcdcdc">(</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">[] { </font><span style="color: "><font color="#d69d85">"c"</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#d69d85">"d"</font></span><font color="#dcdcdc"> })] </font><span style="color: "><font color="#4ec9b0">ValueTuple</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#569cd6">int</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">&gt; a)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">return</font></span><font color="#dcdcdc"> a;<br>}</font></font></font></pre>
<p>This helps an IDE and the compiler to "see" what the element names are and warn if they used incorrectly:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 10pt">// Ok: tuple literal can skip element names</font></font></span><font style="font-size: 10pt"><br><font color="#dcdcdc">(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> y) tpl </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">);<br> </font><br></font><font face="Consolas"><font color="#57a64a"><span style="color: ">// Warning: The tuple element 'a' is ignored because a different name</span><br><span style="color: ">// or no name is specified by the target type '(int x, int y)'.</span></font><br><font color="#dcdcdc">tpl </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (a:</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, b:</font><span style="color: "><font color="#b5cea8">2</font></span></font><font face="Consolas"><font color="#dcdcdc">);<br> </font><br><span style="color: "><font color="#57a64a">// Ok: tuple deconstruction ignore element names</font></span><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> (a, b) </font><span style="color: "><font color="#b4b4b4">=</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> tpl;<br> </font><br><span style="color: "><font color="#57a64a">// x: 2, y: 1. Tuple names are ignored</font></span><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> (y, x) </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> tpl;</font></font></font></pre>
<p>The compiler has stronger requirements for inherited members:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">abstract</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Base</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">abstract</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> a, </font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> b) Foo();<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">abstract</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc">) Bar();<br>}<br> </font><br><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Derived</font></span><font color="#dcdcdc"> : </font><span style="color: "><font color="#4ec9b0">Base</font></span><br></font><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Error: Cannot change tuple element names when overriding method</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">override</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> c, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> d) Foo() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">);<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// Error: Cannot change tuple element names when overriding method</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">override</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> a, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> b) Bar() </font><span style="color: "><font color="#b4b4b4">=&gt;</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span><font color="#dcdcdc">);<br>}</font></font></font></pre>
<p>Regular method arguments can be freely changed in overriden members, tuple element names in overriden members should exactly match ones from a base type.
<h4>Element name inference</h4>
<p>C# 7.1 introduces one additional enhancement: element name inference similar to what C# does for anonymous types.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> NameInference(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc"> y)<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// (int x, int y)</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> tpl </font><span style="color: "><font color="#b4b4b4">=</font></span></font><font face="Consolas"><font color="#dcdcdc"> (x, y);<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> a </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc"> {X </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> x, Y </font><span style="color: "><font color="#b4b4b4">=</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> y};<br> <br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#57a64a">// (int X, int y)</font></span><br><font color="#dcdcdc">&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> tpl2 </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (a</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">X, a</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Y);<br>}</font></font></font></pre>
<h4>Value semantic and mutability</h4>
<p>Tuples are mutable value types with elements as public fields. This sounds concerning because we know that mutable value types considered harmful. Here is a small example of their evil nature:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">var</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc"> x </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc"> { Items </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">List</font></span><font color="#dcdcdc">&lt;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc">&gt; { </font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">2</font></span><font color="#dcdcdc">, </font><span style="color: "><font color="#b5cea8">3</font></span><font color="#dcdcdc"> }</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">GetEnumerator() };</font><br><span style="color: "><font color="#569cd6">while</font></span><font color="#dcdcdc"> (x</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Items</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">MoveNext())<br>{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(x</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Items</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Current);<br>}</font></font></font></pre>
<p>If you'll run this code you'll get ... an infinite loop. <code>List&lt;T&gt;.Enumerator</code> is a mutable value type but <code>Items</code> is a property. This means that <code>x.Items</code> returns a copy of the original iterator on each loop iteration causing an infinite loop.
<p>But mutable value types are dangerous only when the data is mixed with a behavior: an enumerator holds a state (current element) and has a behavior (an ability to advance an iterator by calling <code>MoveNext</code> method). This combination can cause issues because it's so easy to call a method on a copy instead of on an original instance -- causing effectively no-op. Here is a set of examples that can cause an unobvious behavior due to a hidden copy of a value type: <a href="https://gist.github.com/SergeyTeplyakov/8841519120c9858324314e25ddccfc52">gist</a>.
<p>But one issue with mutability still remains:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">var</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc"> tpl </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (x: </font><span style="color: "><font color="#b5cea8">1</font></span><font color="#dcdcdc">, y: </font><span style="color: "><font color="#b5cea8">2</font></span><font color="#dcdcdc">);</font><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> hs </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">new</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">HashSet</font></span><font color="#dcdcdc">&lt;(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc"> y)&gt;();<br>hs</font><span style="color: "><font color="#b4b4b4">.</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc">Add(tpl);<br> <br>tpl</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">x</font><span style="color: "><font color="#b4b4b4">++</font></span><font color="#dcdcdc">;</font><br><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(hs</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Contains(tpl)); </font></font><span style="color: "><font style="font-size: 10pt" color="#57a64a">// false</font></span></font></pre>
<p>Tuples are very useful as keys in dictionaries and can be stored in hash sets due to a proper value semantics. But you should not mutate the state of a tuple variable between different operations with the collection.
<h4>Deconstruction</h4>
<p>Even though the tuple construction is special to the tuples, deconstruction is generic and can be used with any type.<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#569cd6"><font style="font-size: 10pt">public</font></font></span><font style="font-size: 10pt"><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">static</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">class</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">VersionDeconstrucion</font></span><br></font></font><font style="font-size: 10pt"><font face="Consolas"><font color="#dcdcdc">{<br>&nbsp;&nbsp;&nbsp; </font><span style="color: "><font color="#569cd6">public</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">static</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">void</font></span><font color="#dcdcdc"> Deconstruct(</font><span style="color: "><font color="#569cd6">this</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Version</font></span><font color="#dcdcdc"> v, </font><span style="color: "><font color="#569cd6">out</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> major, </font><span style="color: "><font color="#569cd6">out</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> minor, </font><span style="color: "><font color="#569cd6">out</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> build, </font><span style="color: "><font color="#569cd6">out</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#569cd6">int</font></span></font><font face="Consolas"><font color="#dcdcdc"> revision)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; major </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> v</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Major;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> v</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Minor;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> v</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Build;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; revision </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> v</font><span style="color: "><font color="#b4b4b4">.</font></span></font><font face="Consolas"><font color="#dcdcdc">Revision;<br>&nbsp;&nbsp;&nbsp; }<br>}<br> <br></font></font><font face="Consolas"><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> version </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">Version</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Parse(</font><span style="color: "><font color="#d69d85">"1.2.3.4"</font></span><font color="#dcdcdc">);</font><br><span style="color: "><font color="#569cd6">var</font></span><font color="#dcdcdc"> (major, minor, build, </font><span style="color: "><font color="#569cd6">_</font></span><font color="#dcdcdc">) </font><span style="color: "><font color="#b4b4b4">=</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> version;<br> </font><br><span style="color: "><font color="#57a64a">// Prints: 1.2.3</font></span><br><span style="color: "><font color="#4ec9b0">Console</font></span><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">WriteLine(</font><span style="color: "><font color="#d69d85">$"</font></span><font color="#dcdcdc">{major}</font><span style="color: "><font color="#d69d85">.</font></span><font color="#dcdcdc">{minor}</font><span style="color: "><font color="#d69d85">.</font></span><font color="#dcdcdc">{build}</font><span style="color: "><font color="#d69d85">"</font></span><font color="#dcdcdc">);</font></font></font></pre>
<p>&nbsp;</p>
<p>Deconstruction uses "duck-typing" approach: if the compiler can find a method called <code>Deconstruct</code> for a given type - instance method or an extension method - the type is deconstructable.
<h4>Aliasing tuples</h4>
<p>Once you start using the tuples, you'll quickly realize that you want to "reuse" a tuple type with named elements in multiple places in your source code. But there are few issues with that. First, C# does not support global aliases for a given type. You can use 'using' alias directive, but it creates an alias visible in one file. And second, you can't even alias the tuple:<pre style="font-family: ; background: #1e1e1e; color: "><font face="Consolas"><span style="color: "><font color="#57a64a"><font style="font-size: 10pt">// You can't do this: compilation error</font></font></span><font style="font-size: 10pt"><br><span style="color: "><font color="#569cd6">using</font></span><font color="#dcdcdc"> Point </font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> (</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span></font></font><font face="Consolas"><font style="font-size: 10pt"><font color="#dcdcdc"> y);<br> </font><br><span style="color: "><font color="#57a64a">// But you *can* do this</font></span><br><span style="color: "><font color="#569cd6">using</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#4ec9b0">SetOfPoints</font></span><font color="#dcdcdc">&nbsp;</font><span style="color: "><font color="#b4b4b4">=</font></span><font color="#dcdcdc"> System</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Collections</font><span style="color: "><font color="#b4b4b4">.</font></span><font color="#dcdcdc">Generic</font><span style="color: "><font color="#b4b4b4">.</font></span><span style="color: "><font color="#4ec9b0">HashSet</font></span><font color="#dcdcdc">&lt;(</font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> x, </font><span style="color: "><font color="#569cd6">int</font></span><font color="#dcdcdc"> y)&gt;;</font></font></font></pre>
<p>There is a pending discussion on github at <a href="https://github.com/dotnet/csharplang/issues/423">"Tuple types in using directives"</a>. So if you'll find yourself using one tuple type in multiple places you have two options: keep copy-pasting or create a named type.
<h4>What casing for elements should I use?</h4>
<p>Here is an interesting question: what casing rule we should follow for tuple elements? Pascal case like <code>ElementName</code> or camel case like <code>elementName</code>? On one hand, tuple elements should follow the naming rule for public members (i.e. PascalCase), but on the other hand, tuples are just bags with variables and variables are camel cased.
<p>You may consider using a different naming scheme based on the usage and use <code>PascalCase</code> if a tuple is used as an argument or return type of a method and use <code>camelCase</code> if a tuple is created locally in the function. But I prefer to use <code>camelCase</code> all the time.
<h4>Conclusion</h4>
<p>I've found tuples very useful in my day to day job. I need more than one return value from a function, or I need to put a pair of values into a hashset, or I need to change a dictionary and keep not the one value but two, or the key becomes more complicated and I need to extend it with another "field".
<p>I even use them to avoid closure allocation with methods such a <a href="https://github.com/dotnet/corefx/blob/afcbd9a5b9e4ecde2db3a69afd093631f1db91c5/src/System.Collections.Concurrent/src/System/Collections/Concurrent/ConcurrentDictionary.cs#L1010"><code>ConcurrentDictionary.TryGetOrAdd</code></a> that now takes an extra argument. And in many cases the state is a tuple as well.
<p>The feature is very useful but I really want to see a few enhancements:
<ol>
<li>Global aliases: an ability to "name" a tuple and use them in the whole assembly (****). 
<li>Deconstruct a tuple in the pattern matching: in <code>out var</code> and in <code>case var</code>. 
<li>Use operator <code>==</code> for equality comparison.</li></ol>
<p>(****) I know that this feature is debatable, but I think it'll be very useful. We can wait for record types, but I'm not sure if the records will be value types or reference types.</p>